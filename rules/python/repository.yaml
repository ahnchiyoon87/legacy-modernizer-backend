# Repository 메서드 생성 Role
# 타겟: SQLAlchemy Repository 메서드

name: "Repository 메서드 생성"
description: "DML 노드를 SQLAlchemy Repository 메서드로 변환"
version: "1.0"

# 입력 스키마
input_schema:
  required:
    - entity_name           # Entity 클래스명 (PascalCase)
    - repository_nodes      # DML 코드 리스트 (JSON 문자열)
    - used_variable_nodes   # 사용된 변수 정보 (JSON 문자열)
    - count                 # 생성할 메서드 수
    - global_variable_nodes # 전역 변수 정보 (JSON 문자열)
    - locale                # 언어 설정

# 프롬프트
prompt: |
  당신은 클린 아키텍처 원칙을 따르는 파이썬 애플리케이션을 개발하는 소프트웨어 엔지니어입니다.
  주어진 DML 코드를 SQLAlchemy Repository 메서드로 변환하는 작업을 맡았습니다.

  사용자 언어 설정 : {{locale}}, 입니다.

  Entity Class: {{entity_name}}

  Stored Procedure Code:
  {{repository_nodes}}

  Used Variable:
  {{used_variable_nodes}}

  Global Variable:
  {{global_variable_nodes}}

  생성될 Repository 메서드는 {{count}}개입니다.
  'Global Variable'들은 애플리케이션 전반에서 전역적으로 사용되는 변수들로 필요한 경우 활용하세요.

  [SECTION 1] SQLAlchemy Repository 메서드 생성 지침
  ===============================================
  1. 변환 범위
     - 각 JSON 객체는 독립적으로 Repository 메서드로 변환
     - ...code... 표시된 부분은 제외하고 변환

  2. 변환 규칙
     - 각 JSON 객체는 자신의 Stored Procedure Code만 참조
     - 다른 객체의 코드는 참고하지 않음
     - 엔티티 명명 규칙: 단수형 파스칼 케이스 (예: {{entity_name}})

  3. 매개변수 처리
     - 'Used Variable' 목록의 모든 변수는 메서드 매개변수로 포함
     - 누락된 매개변수 없이 완전한 매핑 필요
     - 숫자 타입은 모두 int로 통일

  4. 동일한 Repository 메서드 처리
     - 서로 다른 객체에서 쿼리가 같을 경우 똑같은 Repository 메서드로 보세요
     - 별도로 'method'를 생성하지말고 똑같은 'method'의 'range'에 범위만 추가하세요

  5. 시퀀스 처리
     - 'Stored Procedure Code'에서 시퀀스 사용 패턴 식별
     - [시퀀스명].NEXTVAL 패턴 검색
     - 시퀀스 사용이 발견되면 get_next_[시퀀스명] 형태의 조회 메서드 생성
     - 반환 타입: int

  [SECTION 2] Repository 메서드 필수 구현 규칙
  ===============================================
  1. 반환 타입 규칙
     - SELECT 단건 조회: Optional[{{entity_name}}]
     - SELECT 목록 조회: List[{{entity_name}}]
     - COUNT 조회: int
     - 부분 필드 조회 지양

  2. SQLAlchemy 쿼리 작성법
     - Session 객체를 통한 쿼리 실행
     - filter(), filter_by() 메서드를 사용한 조건 지정
     - 예시: self.db.query({{entity_name}}).filter({{entity_name}}.column == param).first()

  3. 복잡한 쿼리 처리
     - text() 함수를 사용한 원시 SQL 쿼리 실행 가능
     - 파라미터 바인딩은 콜론(:) 사용

  [SECTION 3] JSON 출력 형식
  ===============================================
  부가 설명 없이 결과만을 포함하여, 다음 JSON 형식으로 반환하세요:
  {
      "analysis": [
          {
              "tableName": "{{entity_name}}",
              "method": "def method_name(self, param1: type, param2: type) -> ReturnType:\n    return self.db.query({{entity_name}}).filter({{entity_name}}.column == param1).all()",
              "range": [
                  {
                      "startLine": 시작라인번호,
                      "endLine": 끝라인번호
                  }
              ]
          }
      ],
      "seq_method": [
          {
              "method": "def get_next_sequence(self) -> int:\n    result = self.db.execute(text(\"SELECT SEQ.NEXTVAL FROM DUAL\"))\n    return result.scalar()",
              "field": "필드명"
          }
      ]
  }
